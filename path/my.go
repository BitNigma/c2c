package main

import (
	"encoding/base64"
	"encoding/json"
	"errors"
	"fmt"
	"log"
	"net/http"
	"net/url"
	"os"
	"time"

	"github.com/dgrijalva/jwt-go"
	"github.com/gorilla/mux"
)

const (
	Baseurl = "https://apidev.grapherex.com/api/v1/website-backend/content/"
)

var Urls = map[string]string{
	"/":         "en",
	"about":     "en",
	"contatcs":  "en",
	"wallet":    "en",
	"messenger": "en",
	"exchange":  "en",
	"testpage":  "en",
}

type Autogenerated struct {
	Meta     *Meta  `json:"meta"`
	Visible  string `json:"visible"`
	Sections []*Sec `json:"sections"`
	Template string `json:"template"`
}

type Sec struct {
	Name    string `json:"name"`
	Content string `json:"content"`
}
type Meta struct {
	Title       string `json:"title"`
	Keywords    string `json:"keywords"`
	Description string `json:"description"`
	Lang        string `json:"lang"`
}

var webclient = &http.Client{Timeout: 10 * time.Second}

func loadPage(url string, target interface{}) error {
	resp, err := webclient.Get(url)
	if err != nil {
		log.Fatal(err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return errors.New("not found")

	}
	err = json.NewDecoder(resp.Body).Decode(target)
	if err != nil {
		log.Fatal(err)
	}

	return err

}

func viewHandler(w http.ResponseWriter, r *http.Request) {

	data := &Autogenerated{}
	path, ok := Mapkey("testpage", "en")

	if !ok {
		fmt.Println(0, path)
	}

	err := loadPage(path, &data)
	if err != nil {
		http.Redirect(w, r, "/404", http.StatusBadRequest)
		return
	}
	//fill(data)
	fmt.Println(0, data)

}

func fill(data *Autogenerated) *Autogenerated {
	for i, content := range data.Sections {
		ensstr, err := base64.StdEncoding.DecodeString(content.Content)
		if err != nil {
			log.Fatal(err)
		}
		data.Sections[i].Content = string(ensstr)
	}
	return data
}

func errHandler(w http.ResponseWriter, r *http.Request) {
	fmt.Fprintf(w, "<h1>%s</h1>", "Page Not found")
}

/*
var testurl = `^/(about|contacts|messenger|wallet|exchange)+$`
var validPath *regexp.Regexp

func makeHandler() http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		m := validPath.FindStringSubmatch(r.URL.Path)
		if m != nil {
			fmt.Fprintf(w, "<h1>%s</h1><dib><b>%s</b<</div>", "find", r.URL.Path)
			return
		}
		http.NotFound(w, r)
		return
	}
} */

/* s */
/* func my(w http.ResponseWriter, r *http.Request) {
	validPath := []string{"contacts", "about", "wallet", "messenger", "exchange", "blog"}
	var ok int
	url := r.URL.Path[len("/"):]
	for _, value := range validPath {
		ok = strings.Compare(url, value)
		if ok == 0 {
			break
		}
	}
	if ok == 0 {
		fmt.Fprintf(w, "<h1>%s</h1><div>%s</di>", r.URL.Path, "good")
		return
	}
	fmt.Fprintf(w, "<h1>%s</h1><div>%s</di>", r.URL.Path, "no match")

}  */

func oauthhandle() http.HandlerFunc {

	return func(w http.ResponseWriter, r *http.Request) {

		cookie, err := r.Cookie("token")
		if err != nil {
			if err == http.ErrNoCookie {
				w.WriteHeader(http.StatusUnauthorized)
				return
			}
			w.WriteHeader(http.StatusBadRequest)
			return
		}

		tokenStr := cookie.Value
		claims := &Claims{}

		tkn, err := jwt.ParseWithClaims(tokenStr, claims,
			func(t *jwt.Token) (interface{}, error) {
				return jwtKey, nil
			})

		if err != nil {
			if err == jwt.ErrSignatureInvalid {
				w.WriteHeader(http.StatusUnauthorized)
				return
			}
			w.WriteHeader(http.StatusBadRequest)
			return
		}

		if !tkn.Valid {
			w.WriteHeader(http.StatusUnauthorized)
			return
		}
		data := &Autogenerated{}
		path, ok := Mapkey("index", "en")
		if !ok {
			fmt.Println(0, path)
		}
		//view html template
		fmt.Fprintf(w, "<div>%+v</di><p>%+v</p>", data, claims.Username+" "+cookie.Value)
	}
}

func Mapkey(path, lang string) (key string, ok bool) {
	for k, v := range Urls {
		if k == path {
			key = k
			ok = true
			return Baseurl + key + "/" + v, ok
		}
	}
	return
}

var token = "82e03fbc-7930-462c-8af1-8acc3ff9b545"
var api = "https://pro-api.coinmarketcap.com/v1/cryptocurrency/listings/latest"

func coinhabdle() http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		client := webclient
		req, err := http.NewRequest("GET", "https://pro-api.coinmarketcap.com/v1/cryptocurrency/listings/latest", nil)
		if err != nil {
			log.Print(err)
		}
		req.Header.Set("Accepts", "application/json")
		req.Header.Add("X-CMC_PRO_API_KEY", token)

		q := url.Values{}
		q.Add("start", "1")
		q.Add("limit", "10")
		q.Add("convert", "USD")
		req.URL.RawQuery = q.Encode()

		resp, err := client.Do(req)
		if err != nil {
			fmt.Println("Error sending request to server")
			os.Exit(1)
		}
		defer resp.Body.Close()

		fmt.Println(resp.Status)
		var result map[string]interface{}
		err = json.NewDecoder(resp.Body).Decode(&result)
		if err != nil {
			log.Fatalln(err)
			os.Exit(1)
		}

		data, _ := json.MarshalIndent(result, " ", "\t")
		if err != nil {
			log.Fatalln(err)
			os.Exit(1)
		}
		fmt.Println(string(data))
		fmt.Fprintf(w, "<div>%+v \n</div>", string(data))

	}

}

var jwtKey = []byte("secret_key")

var users = map[string]string{
	"jonny":  "flints",
	"tomato": "1488",
}

type Credentials struct {
	Username string `json:"username"`
	Password string `json:"password"`
}

type Claims struct {
	Username string `json:"username"`
	jwt.StandardClaims
}

func login(w http.ResponseWriter, r *http.Request) {
	var credentials Credentials
	err := json.NewDecoder(r.Body).Decode(&credentials)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		return
	}

	expassword, ok := users[credentials.Username]
	if !ok || expassword != credentials.Password {
		w.WriteHeader(http.StatusUnauthorized)
		return
	}

	exptime := time.Now().Add(time.Minute * 5)
	claims := &Claims{
		Username: credentials.Username,
		StandardClaims: jwt.StandardClaims{
			ExpiresAt: exptime.Unix(),
		},
	}

	rawtoken := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
	tokenString, err := rawtoken.SignedString(jwtKey)

	if err != nil {

		w.WriteHeader(http.StatusInternalServerError)
		return
	}

	http.SetCookie(w, &http.Cookie{
		Name:    "token",
		Value:   tokenString,
		Expires: exptime,
	})

}

func refresh(w http.ResponseWriter, r *http.Request) {
}

func main() {
	router := mux.NewRouter()
	r := router.StrictSlash(true)

	r.HandleFunc("/coin", coinhabdle())
	r.HandleFunc("test", viewHandler)
	//r.HandleFunc(`/{title:[a-zA-Z0-9=\-\/]+}`, viewHandler)
	//r.HandleFunc("/404", errHandler)
	//r.HandleFunc("/test", my)
	//r.HandleFunc("/testpage", mainhandle()).Methods("GET")
	//r.HandleFunc("/login", login).Methods("POST")
	//r.HandleFunc("/refresh", refresh)
	//http.HandleFunc("/edit/", makeHandler(editHandler))
	//http.HandleFunc("/save/", makeHandler(saveHandler))

	log.Fatal(http.ListenAndServe(":8080", router))

}
